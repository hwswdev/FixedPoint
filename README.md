Может ли sin(x) и cos(x), всегда быть строго меньше единицы?
Я рассчитывал значения этих функций, не для использования в математических пакетах,
а для личного применения в станке CNC.

Для рассчетов решил отказаться от float и dobule и перейти к математике с фиксированной точкой.
В процессе рассчетов, я понял что при расчете sin(x) и cos(x) на интервале 0..PI/4,
можно обойтись только положительными числами в диапазоне 0..1.
В таком случае любое значение можно представить как сумму Ai * 2^i,
где i лежит в интервале от -N до M. отрицательные значения i, дают нам представление 
дробной части числа. Положительные значения i дают представление целой части.

В процессе рассчета, применил разложение функций, в ряд Тейлора.
Через некоторое время понял что если апроксимировать sin в диапазоне 0..PI/4 
достаточно только положительных чисел, т.к. sin(x) и cos(x) укладываются в 
диапазон от 0..1. Кроме того, все коэффициенты и множители так-же укладываются
в диапазон 0...1. Поскольку произведение чисел в диапазоне 0..1, даст число 
всегда больше или равное 1, то умножение двух таких чисел даст число 
меньше единицы.
Данный код написан под ARM Cortex M3. Все числа в формате FixedPoint
представлены как числа строго меньше 1. Если быть точно, то представление
числа это сумма коэффициентов и множителей от 1/2,1/4,1/8,...до 1/(2^32)
1/2^32 дает точность порядка 2.33*(10 ^ -10). Т.е. около 9 знаков после запятой.

В общем и целом это очевидные вещи, но, произведение двух 32-бинтых чисел
в таком случае дает число 64-битное. При этом младшие 32-бита можно отбросить
с потерей точности, но не потерей значения.

Если представить операции делители коэффициентов ряда Тейлора, как дробные 
положительные числа, это приведет к замене операции деления на операцию
умножения. А значит, в процессе разложения я отказался от операции деления,
которая обычно выполняется дольше.

Я использовал только 32-битные операции, за исключением одной. 
Аргумент sin, был приведен к диапазону от 0..1. Это операция умножения 
на число 0x6487ed510. Если умножить 32-битное число в диапазоне 0..1/8
представленное как коэффициенты 1/2^N  на 0x6487ed510, то выходные 32-бита
будут содержать значение в диапазоне 0..PI/4, что требуется для рассчетаэ
sin(x) и cos(x) в этом диапазоне. Можно заметить что 0x6487ed510, содержит 
не 32 разряда, а 36 разрядов. Это не укладвается в 32-битную арифметику.
По этому я сдвинул число на три разряда, получив 0xc90fdaa2, которое 
уже укладывается в 32-бита. Однако, произведение, получившееся в результате
нужно сдвинуть на 3 разряда вверх. А младшие разряды дополнить старшими
разрядами младшей частьи произведения. Это даст приведение диапазона 
от 0..1/8 к диапазону от 0..PI/4.  Произведение, можно использовать
и со значениеми немного большими чем 1/8, и результатом немного больше 
PI/4. Но затем будет происходить усечение старших частей.

Однако, функции sin(x) и cos(x) в моем случае раскладываются на интервале
0.. PI/4 а остальные значения приводятся в этот диапазон. А значит,
другие значение не требуются. Функция отработает как положено.

А теперь вопрос, для чего такие сложности? Все просто, я использовал операции 
умножения, и брал только старшие слова, как результат умножения. Это позволило
убрать сдвиги результата после умножения (фактически, сдвиг на 32-бита).
Кроме того, я отказался от бита знака и таким образом в процессе вычисления
производил операции с точностью 2^-32 (да, с усечением).

А теперь внимание, к чему это привело. Входные данные в функции можно представить 
как полный диапазон числа uin32_t или int32_t. Это и будет диапазоном от 0 до 2*PI,
или диапазоном от [-PI..PI]. Это означает что можно впринципе и не думать что работаешь
с FixedPoint значением. Результат, так-же получается смаштабирован в диапазон от 
минимального до максимального значения int32_t. К сожалению, значения sin(x) и
cos(x) в этом случае не могут ринимать значения эквивалентного 1.0. 
Но может принимать значение 0.999(9). 

На самом деле обычное целочисленное умножение A на результат функции sinFixed(x) или cosFixed(x)
с отбрасыванием младшей части, даст масштабирование этого числа до A*sin(x), A*cos(x), сточностью
до одного разряда. Да, не следует забывать об ошибках вычисления самих функций. Но по факту эти 
sinFixed и cosFixed могут так-же спокойно работать с целочисленной арифметикой. Все у нас в голове,
и это не имеет значения. Кроме того в качестве аргумента можно использовать как uint32_t, так и int32_t.
Это так-же не имеет значения. sinFixed и sinFixedSigned это просто алиасы на один и тот же код.
Т.е. нет разницы -MIN..+MAX (для int32_t) или MIN..MAX (для uint32_t).

Так для чего это нужно было мне? 
При вычислении дуги окружности, можно использовать формулу Y= sqrt(1 - X*X), или формулу
X = R*cos(a) Y=R*sin(a). В первом случае шаг по осям переменный и рассчитать интервалы и
скорость движения сложно. В случае же использования определенного приращения угла ai = ai + dA
dA есть фиксированное значение, а значит это даст фиксированную длинну дуги, и фиксированную скорость.
Но самое главное, умножение радиуса на значение даст мне максимальное число строго меньше радиуса (на один разряд)


